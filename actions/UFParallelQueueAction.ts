/**
 * @version 1
 * @author Josha Munnik
 * @copyright Copyright (c) 2022 Ultra Force Development
 * @license
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * <ul>
 * <li>Redistributions of source code must retain the above copyright notice, this list of conditions and
 *     the following disclaimer.</li>
 * <li>The authors and companies name may not be used to endorse or promote products derived from this
 *     software without specific prior written permission.</li>
 * </ul>
 * <br/>
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

// region imports

import {IUFQueueableAction} from "./IUFQueueableAction";
import {UFQueueableAction} from "./UFQueueableAction";
import {IUFCancellationToken} from "./IUFCancellationToken";
import {UFProgressTools} from "../tools/UFProgressTools";
import {UFCancellationTokenSource} from "./UFCancellationTokenSource";
import {UFText} from "../tools/UFText";

// endregion

// region exports

/**
 * {@link UFParallelQueueAction} implements an action queue that can run a number of actions at the same time.
 *
 * It extends {@link UFQueueableAction} so the queue can be placed into other queues if needed.
 */
export class UFParallelQueueAction extends UFQueueableAction {
  // region private vars

  /**
   * Original actions list
   *
   * @private
   */
  private readonly m_actions: IUFQueueableAction[];

  /**
   * Current promises being resolved.
   *
   * Since {@link Promise.race} does return the result of the promise, store the promises together with the index of
   * the action. The promise will return the same index value, so it can be removed from the map once it has finished.
   *
   * @private
   */
  private readonly m_activePromises: Map<number, Promise<number>> = new Map();

  /**
   * Maximum number of actions to run concurrently
   *
   * @private
   */
  private readonly m_concurrentCount: number;

  /**
   * Total progress weight of all actions.
   *
   * @private
   */
  private readonly m_totalProgressWeight: number;

  /**
   * Sum of progress weight of all actions that have finished.
   *
   * @private
   */
  private m_doneProgressWeight: number = 0.0;

  /**
   * Points to the current action being processed
   *
   * @private
   */
  private m_actionIndex: number = 0;

  /**
   * Combines the error messages generated by the actions.
   *
   * @private
   */
  private m_errorMessage: string = '';

  // endregion

  // region public methods

  /**
   * Constructs an instance of {@link UFParallelQueueAction} that will run a certain number of actions at the same time.
   *
   * @param aConcurrentCount
   *   Maximum number of actions that should run at the same time.
   * @param anActions
   *   One or more actions to run
   * @protected
   */
  constructor(aConcurrentCount: number, ...anActions: IUFQueueableAction[]) {
    super();
    this.m_actions = anActions;
    this.m_concurrentCount = aConcurrentCount;
    this.m_totalProgressWeight = anActions.reduce(
      (previous, current) => previous + UFProgressTools.getProgressWeight(current),
      0
    );
  }

  /**
   * Runs all stored actions at the same time.
   *
   * If the queue is already running, the method just returns true.
   *
   * @param aToken
   *   Token that can be cancelled to stop running.
   *
   * @return true if all actions run successful; false if one of the actions returned false or the token was cancelled.
   *
   * @throws an error if one or more actions threw an error.
   */
  public async run(aToken: IUFCancellationToken): Promise<boolean> {
    if (this.running) {
      return true;
    }
    this.m_doneProgressWeight = 0.0;
    this.m_actionIndex = 0;
    this.m_errorMessage = '';
    const tokenSource = new UFCancellationTokenSource(aToken);
    await this.runActions(tokenSource);
    // success if no task did cancel or threw an exception
    const result: boolean = !tokenSource.isCancellationRequested;
    // throw an exception if one or more actions threw an exception
    if (this.m_errorMessage.length) {
      throw new Error(`One or more actions raised an error: ${this.m_errorMessage}`);
    }
    return result;
  }

  /**
   * Gets all current running actions.
   */
  getRunningActions(): IUFQueueableAction[] {
    const result: IUFQueueableAction[] = [];
    this.m_activePromises.forEach((promise, index) => {
      result.push(this.m_actions[index]);
    });
    return result;
  }

  // endregion

  // region public properties

  /**
   * True if the queue still has at least one running action.
   */
  public get running(): boolean {
    return this.m_activePromises.size > 0;
  }

  /**
   * Number of running actions.
   */
  public get runningCount(): number {
    return this.m_activePromises.size;
  }

  // endregion

  // region IUFProgress

  /**
   * Gets the progress, include the progress of any running action.
   */
  public get progress(): number {
    let progressSum: number = 0;
    this.m_activePromises.forEach((value, index) => {
      const action = this.m_actions[index];
      progressSum += UFProgressTools.getProgressWeight(action) * UFProgressTools.getProgress(action);
    });
    return (progressSum + this.m_doneProgressWeight) / this.m_totalProgressWeight;
  }

  // endregion

  // region protected methods

  // endregion

  // region private methods

  /**
   * Runs all actions.
   *
   * @param aTokenSource
   *   Will be cancelled if an action returned false or generated an error.
   *
   * @private
   */
  private async runActions(aTokenSource: UFCancellationTokenSource): Promise<void> {
    // keep looping if there are actions that still can be added or if there are any active actions still running
    while (
      (!aTokenSource.isCancellationRequested && (this.m_actionIndex < this.m_actions.length)) ||
      (this.m_activePromises.size > 0)
      ) {
      this.addPromises(aTokenSource);
      await this.waitForPromiseToFinish();
    }
  }

  /**
   * Waits for one of the active promises to resolve.
   *
   * @private
   */
  private async waitForPromiseToFinish() {
    const index = await Promise.race(Array.from(this.m_activePromises.values()));
    this.m_activePromises.delete(index);
  }

  /**
   * Keep adding promises to the active list until the concurrent maximum is reached or the action has been cancelled.
   *
   * @param aTokenSource
   */
  private addPromises(aTokenSource: UFCancellationTokenSource) {
    while (
      !aTokenSource.isCancellationRequested
      && (this.m_actionIndex < this.m_actions.length)
      && (this.m_activePromises.size < this.m_concurrentCount)
      ) {
      this.m_activePromises.set(
        this.m_actionIndex, this.runAction(this.m_actionIndex, aTokenSource)
      );
      this.m_actionIndex++;
    }
  }

  /**
   * Runs an action. If the action returned false or threw an exception, call cancel on the token source.
   *
   * @param anIndex
   *   Index to running action
   * @param aTokenSource
   *   Token source that will be cancelled if an error occurred or action returned false.
   *
   * @return index of action (value of anIndex)
   *
   * @private
   */
  private async runAction(anIndex: number, aTokenSource: UFCancellationTokenSource): Promise<number> {
    // get action and store it in the running list while it is active
    const action = this.m_actions[anIndex];
    let actionResult: boolean;
    try {
      actionResult = await action.run(aTokenSource.token);
    } catch (error: any) {
      // an error will also stop all other actions
      actionResult = false;
      this.m_errorMessage = UFText.append(this.m_errorMessage, `${error.name}: ${error.message}`, ',');
    }
    // either cancel all other actions or increase progress weight
    if (!actionResult) {
      aTokenSource.cancel();
    }
    else {
      this.m_doneProgressWeight += UFProgressTools.getProgressWeight(action);
    }
    // return index of action
    return anIndex;
  }

  // endregion
}

// endregion